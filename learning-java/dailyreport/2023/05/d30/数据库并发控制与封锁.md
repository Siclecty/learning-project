#### 数据库并发控制与封锁

##### 事务及其性质

事务特性（ACID）：

1. 原子性：事务是原子的，要么都做，要么都不做。

2. 一致性：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性的状态。因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。

3. 隔离性：事务相互隔离，当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的。

4. 持续性：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。

###### 封锁协议：

共享锁（S锁）：

* 若事务T对数据对象A添加了S锁，则只允许T读取A，但不能修改A。并且其他事务只能对A加S锁，不能加X锁。

排他锁（X锁）：

* 若事务T对数据对象A添加了X锁，则只允许T读取和修改A，其他事务不能再对A加任何锁。

并发产生的问题：

* 丢失更新， 不可重复读，读“脏”数据 

###### 死锁与活锁

* 死锁：等待锁关系之间出现循环等待。

* 活锁：某个时候等待相当长时间仍然申请不到锁。

* 按先进先出排个队

* 解决方法：

###### 死锁的解决办法

* 防止出现死锁

* 找出牺牲者，避免死锁

##### 死锁检测与死锁预防

##### 死锁检测

* 超时法：设定一个等待时限

* 超过这个时限就是死锁了

* 构造等待图：顶点集合就是参于的事务，等待关系就是边

* 出现一条新边

* 安排一个后台线程，周期性检查

* 一旦等待图出现环路，那么就是出现死锁了

* 检查环路的时机

###### 死锁预防

* 给每个事务安排时间戳

* 等待关系单方面，不会出现死锁

* TID 事务的ID

* 比较两个事务的年龄

* 时间戳的作用：

* 等死法：
  + 当TA要申请的锁被Tb占有了，比较两者时间戳，如果自己年龄更小，就杀了自己sleep一会再运行，自己年龄更大，就等待。

* 等法：
  + 当TA要申请的锁被Tb占有了，比较两者时间戳，如果比较更小，就等待，自己年龄大，就杀了自己sleep一会再运行。 